#!/usr/bin/python

import os, platform, shutil, subprocess, sys

try: input=raw_input
except: pass

this=os.path.realpath(__file__)

def timestamp(ambiguous=True):
	import datetime
	format='{:%Y-%m'
	if not ambiguous: format+='-%b'
	format+='-%d %H:%M:%S.%f}'
	return format.format(datetime.datetime.now()).lower()

def _home_path(path): return os.path.join(os.path.expanduser('~'), *path.split('/'))

def _invoke(invocation):
	if '--dry' in sys.argv: print(invocation)
	else: subprocess.check_call(invocation, shell=True)

opener=None
if   not subprocess.call('which xdg-open', shell=True): opener='xdg-open'
elif not subprocess.call('which open'    , shell=True): opener='open'
if not opener and platform.system()=='Windows': opener='explorer'

_dan_bash='''force_color_prompt=yes
PATH=$PATH:~/Desktop/scripts
PS1='\\e[0;37;44m               $?               \\e[m \n\\h \\t \\w$ '
alias o="{} ."
echo "dan bash ran"
'''.format(opener)

def bash():
	'update bash setup, writes to ~/Desktop/scripts/'
	try: os.makedirs(_home_path('Desktop/scripts'))
	except: pass
	shutil.copy(this, _home_path('Desktop/scripts'))
	with open(_home_path('Desktop/scripts/dan-bash.sh'), 'w') as file: file.write(_dan_bash)

def sleep(): _invoke('systemctl suspend')

def reboot(): _invoke('reboot')

def off(): _invoke('poweroff')

def link(link, linked):
	_invoke('ln -s {} {}'.format(linked, link))

def find(name):
	'find file with name within current directory'
	_invoke('find . -name {}'.format(name))

def vu():
	'volume up'
	_invoke('pactl -- set-sink-volume 0 +10%')

def vd():
	'volume down'
	_invoke('pactl -- set-sink-volume 0 -10%')

def _brightness(level):
	path='/sys/class/backlight/intel_backlight/brightness'
	if level=='get':
		with open(path) as file:
			return int(file.read())
	_invoke('echo {}|sudo tee {}'.format(int(level), path))

def b(level):
	'set brightness'
	if level=='get': return (_brightness('get')-5000)/1000.0
	_brightness(int(level)*1000+5000)

def bu():
	'brightness up'
	b(b('get')*2)

def bd():
	'brightness down'
	b(b('get')//2)

def i(command):
	'append a note of this command to Desktop/dan-install.txt'
	with open(_home_path('Desktop/dan-install.txt'), 'a') as file:
		file.write(timestamp(False)+'\n')
		file.write(command+'\n')
		file.write('\n')
	_invoke(command)

def install_self():
	'hook into bash init script'
	#find bash init script
	bash_init=None
	if os.path.exists(_home_path('.bash_profile')): bash_init=_home_path('.bash_profile')
	elif os.path.exists(_home_path('.bashrc')): bash_init=_home_path('.bashrc')
	if not bash_init:
		print("couldn't find a bash init script!")
		sys.exit(1)
	#append if not already done
	header="#=====appended by dan from dansgithubuser's playground=====#"
	already_done=False
	with open(bash_init, 'r') as file:
		for line in file.readlines():
			if header in line:
				already_done=True
				break
	if not already_done:
		print('I will append to {} and make it use my bash command -- if that is OK, enter y'.format(bash_init))
		if input()!='y': sys.exit(1)
		with open(bash_init, 'a') as file:
			file.write("\n\n{}\n".format(header))
			file.write('python {} bash\n'.format(this))
			file.write('source {}\n'.format(_home_path('Desktop/scripts/dan-bash.sh')))
			file.write('#=====end dan=====#\n')
	#other stuff
	vi()
	git()

_vimrc='''set autoindent
set number
set tabstop=2
set list
set nocompatible
syntax on
set pastetoggle=<F2>
'''

def vi():
	p=_home_path('.vimrc')
	print('I will create a .vimrc file.')
	if os.path.exists(p): print('I will overwrite the existing one.')
	print('If that is OK, enter y.')
	if input()!='y': sys.exit(1)
	with open(p, 'w') as file: file.write(_vimrc)

def git():
	'update git aliases'
	_invoke('sh git-aliases.txt')

def disk_usage(): _invoke('ncdu')

def monitor(): _invoke('top')

_conservative_logrotate_conf='''size 1M
rotate 0
create
include /etc/logrotate.d
/var/log/wtmp {
	missingok
	monthly
	create 0664 root utmp
	rotate 1
}

/var/log/btmp {
	missingok
	monthly
	create 0660 root utmp
	rotate 1
}
'''

_conservative_rsyslog='''/var/log/syslog
{
	rotate 0
	size 1M
	missingok
	postrotate
		invoke-rc.d rsyslog rotate > /dev/null
	endscript
}

/var/log/mail.info
/var/log/mail.warn
/var/log/mail.err
/var/log/mail.log
/var/log/daemon.log
/var/log/kern.log
/var/log/auth.log
/var/log/user.log
/var/log/lpr.log
/var/log/cron.log
/var/log/debug
/var/log/messages
{
	rotate 0
	size 1M
	missingok
	sharedscripts
	postrotate
		invoke-rc.d rsyslog rotate > /dev/null
	endscript
}
'''

def conservative_logrotate():
	with open('/etc/logrotate.conf') as file: file.write(_conservative_logrotate_conf)
	with open('/etc/logrotate.d/rsyslog') as file: file.write(_conservative_rsyslog)

def last():
	print(sorted(os.listdir('.'))[-1])

def help(command=None):
	import inspect
	if command==None:
		print('list of commands:')
		print(sorted([i for i in globals() if callable(eval(i)) and not i.startswith('_')]))
		print('specify a command for help with it')
	else:
		print(inspect.getdoc(eval(command)))
		print(inspect.getargspec(eval(command)))

try: user_command=eval(sys.argv[1])
except: help(); sys.exit(1)
try: exec(sys.argv[1]+'(*sys.argv[2:])')
except TypeError: help(user_command); sys.exit(1)
