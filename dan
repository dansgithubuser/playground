#!/usr/bin/env python3

from __future__ import print_function

import argparse
import datetime
import functools
import getpass
import glob
import inspect
import math
import os
import platform
import pprint
import re
import secrets
import shutil
import string
import subprocess
import sys
import tempfile
import time
import webbrowser

class _Emoji:
    explode = '\U0001f4a5'
    neutral = '\U0001f610'

try: _input = raw_input
except: _input = input

this = os.path.realpath(__file__)

try:
    computer = subprocess.check_output('hostname').decode().strip()
except:
    computer = None

class _Section:
    def __init__(self):
        self.line = inspect.stack()[1][2]

class _SubSection(_Section): pass

def _home_path(path=''): return os.path.join(os.path.expanduser('~'), *path.split('/'))
def _this_path(path=''): return os.path.join(os.path.split(this)[0], *path.split('/'))
def _scripts_path(path=''): return _home_path('Desktop/scripts/'+path)
def _tmp_path(path=''):
    tmp = _this_path('tmp')
    os.makedirs(tmp, exist_ok=True)
    return os.path.join(tmp, path)

def _invoke(invocation, stdin=None, stdout=None):
    if args.dry:
        print(invocation)
        return
    if stdout is not None:
        return subprocess.check_output(invocation, shell=True, stdin=stdin).decode().strip()
    else:
        subprocess.check_call(invocation, shell=True, stdin=stdin)

def _platform_invoke(linux=None, darwin=None, windows=None, **kwargs):
    invocation = {
        'Linux': linux,
        'Darwin': darwin,
        'Windows': windows,
    }[platform.system()]
    if invocation == None: raise Exception('unimplemented')
    return _invoke(invocation, **kwargs)

def _check():
    if args.force: return
    import traceback
    traceback.print_stack()
    print('confirm action (y/n)')
    if input().lower() != 'y':
        print('aborting')
        sys.exit(0)
    else:
        print('confirmed')

def _clipboard_paste(**kwargs):
    return _platform_invoke(
        linux='xclip -selection clipboard -o',
        darwin='pbpaste',
        **kwargs
    )

opener = None
if platform.system() == 'Windows':
    opener = 'explorer'
else:
    if   not subprocess.call('which xdg-open>/dev/null', shell=True): opener = 'xdg-open'
    elif not subprocess.call('which open    >/dev/null', shell=True): opener = 'open'

_dan_bash = '''
#===== config =====#
force_color_prompt=yes
PATH=$PATH:~/Desktop/scripts
PS1_PART1='\\e[0;37;44m               $?               \\e[m'
PS1="$PS1_PART1
$DAN_PS1_UNIQUIFIER\\h \\D{{%Y-%m-%d}} \\t \\w$ "

#===== aliases =====#
#----- folders -----#
alias pg="cd ~/Desktop/repos/playground"
alias repos="cd ~/Desktop/repos"

#----- sleep -----#
alias ds="dan dan \\"wait 3600\\" \\"sleep\\""
alias dsd="dan sleep deep"
alias dss="dan sleep"

#----- brightness -----#
alias b="dan b 40"
alias bb="dan b 500"
alias bn="dan b 4"
alias bnn="dan b -4"

#----- shortcuts -----#
alias o="{opener} ."
alias p3=python3
alias dkr="sudo docker"
alias d="python3 do.py"

#----- overrides -----#
alias vi="dan rename_tab_and_open vi"

#----- tab naming -----#
alias tp="dan rename_tab_pwd; export DAN_TAB_NAME_KEEP=1"

function tn {{
    dan rename_tab "$1"
    export DAN_TAB_NAME_KEEP=1
}}

function tt {{
    if [ $# -eq 0 ]
    then dan rename_tab_pwd "||"
    else dan rename_tab "|| $1 ||"
    fi
    export DAN_TAB_NAME_KEEP=1
}}

#----- docker -----#
function dkrsh {{
    sudo docker exec -it $1 /bin/sh
}}
function dkrbash {{
    sudo docker exec -it $1 /bin/bash
}}

#===== external scripts =====#
if [ -f ~/git-completion.bash ]; then source ~/git-completion.bash; fi

#===== start command =====#
eval $DAN_START_CMD

#===== breadcrumb =====#
echo "dan bash ran"
'''.format(opener=opener)

if os.path.exists(_scripts_path('dan-aliases.txt')):
    with open(_scripts_path('dan-aliases.txt')) as file:
        _dan_bash += file.read()

#=====commands=====#
_computer = _Section()

def sleep(type=None):
    'put computer to sleep'
    if type == 'deep':
        for i in [
            'LID0',
            'SLPB',
            'UHC0',
            'UHC1',
            'UHC2',
            'UHC3',
            'UHC4',
            'UHCR',
            'EHC1',
            'EHC2',
        ]:
            _invoke('sudo sh -c "echo {} > /proc/acpi/wakeup"'.format(i))
    _invoke('systemctl suspend -i')

def reboot():
    'reboot computer'
    _check()
    _invoke('reboot')

def off():
    'turn computer off'
    _check()
    _platform_invoke('sudo poweroff', 'sudo halt')

def vu():
    'volume up'
    _invoke('pactl -- set-sink-volume 0 +10%')

def vd():
    'volume down'
    _invoke('pactl -- set-sink-volume 0 -10%')

def _brightness(level):
    #find path on new computer with `sudo find /sys/ -type f -iname '*brightness*'`
    if computer == 'dan-ThinkPad-13':
        path = '/sys/devices/pci0000:00/0000:00:02.0/drm/card0/card0-eDP-1/intel_backlight/brightness'
        level /= 1000
    else:
        path = '/sys/class/backlight/intel_backlight/brightness'
    if level == 'get':
        with open(path) as file:
            return int(file.read())
    _invoke('echo {}|sudo tee {}'.format(int(level), path))

def b(level):
    'set brightness'
    if level == 'get': return (_brightness('get')-5000)/1000.0
    _brightness(int(float(level)*1000+5000))

def bu():
    'brightness up'
    b(b('get')*2)

def bd():
    'brightness down'
    b(b('get')//2)

def install(command):
    'append a note of this command to Desktop/dan-install.txt'
    with open(_home_path('Desktop/dan-install.txt'), 'a') as file:
        file.write(timestamp(False)+'\n')
        file.write(command+'\n')
        file.write('\n')
    _invoke(command)

def ps():
    'run ps with the best options'
    invoke('ps -e --forest u')

def kill(name):
    'kill a process by name'
    lines = [
        i
        for i in _invoke('ps -e', stdout=True).splitlines()
        if name in i
    ]
    if len(lines) > 1:
        print('multiple matches')
        for line in lines: print(line)
    elif not lines:
        print('no matches')
    else:
        line = lines[0]
        print(line)
        proc = line.split()[0]
        print('killing', proc)
        _invoke(f'kill -9 {proc}')

def kill_the_greedy():
    t_report = 0
    def clear_line():
        print('\033[K', end='\r')
    while True:
        free_split = subprocess.check_output(['free']).decode().split()
        mem_free = int(free_split[12])
        mem_total = int(free_split[7])
        t = time.time()
        if t - t_report > 600:
            end = '\n'
            t_report = t
        else:
            end = '\r'
        clear_line()
        print(f'{mem_free / 1e6:.3f} / {mem_total / 1e6:.3f} GB free', end=end)
        if mem_free < 1_000_000:
            pid = subprocess.check_output(['ps', '-e', '--sort', '%mem']).decode().splitlines()[-1].split()[0]
            subprocess.check_call(['kill', pid])
            clear_line()
            print(f'killed {info[-1]}')
        time.sleep(0.1)

def temperature():
    _invoke('cat /sys/class/thermal/thermal_zone*/temp')

def cpu_frequency():
    try:
        _invoke('cpufreq-info')
    except Exception as e:
        print('Exception:', e)
        print('Try `sudo apt install cpufrequtils`.')

def set_cpu_frequency_governor(governor):
    assert os.path.exists('/etc/default')
    if not os.access('/etc/default', os.W_OK):
        _invoke(f'sudo {this} set_cpu_frequency_governor {governor}')
        return
    with open('/etc/default/cpufrequtils', 'w') as f:
        f.write(f'GOVERNOR="{governor}"\n')

def gpu_info():
    print('===== lshw =====')
    _invoke('sudo lshw -c display')
    print()
    print('===== glxinfo =====')
    _invoke('glxinfo -B')

def listening_ports():
    _invoke('sudo netstat -lntup')

def battery_microwattage():
    _invoke('cat /sys/class/power_supply/BAT*/power_now')

_convenience = _Section()
_convenience_text = _SubSection()

def _put_in_clipboard(contents):
    stdin = tempfile.TemporaryFile(mode='w')
    stdin.write(contents)
    stdin.seek(0)
    _platform_invoke(
        linux='xclip -selection clipboard',
        darwin='pbcopy',
        stdin=stdin,
    )

def clipboard_copy(strip=True):
    'copy stdin to clipboard'
    if strip:
        x = stdin.strip()
    else:
        x = stdin
    print(f'copied {x} to clipboard')
    _put_in_clipboard(x)

def clipboard_paste():
    'paste clipboard to stdout'
    _clipboard_paste()

_snippet_prefix = 'dan-snippet-'

def snipw(name):
    'take clipboard contents and save it as a snippet'
    with open(_scripts_path(_snippet_prefix+name), 'wb') as file:
        file.write(subprocess.check_output('dan v', shell=True))

def snipr(name):
    'put snippet contents into clipboard'
    with open(_scripts_path(_snippet_prefix+name)) as file:
        _put_in_clipboard(file.read())

def snipl():
    'list snippets'
    snippets = []
    for i in sorted(os.listdir(_scripts_path())):
        if i.startswith(_snippet_prefix):
            with open(_scripts_path(i)) as file:
                first_line = file.readlines()[0].strip()
            snippets.append((i[len(_snippet_prefix):], first_line))
    space = max([len(i[0]) for i in snippets])
    for name, first_line in snippets:
        print(('{:'+str(space)+'}: {}').format(name, first_line))

def replace(pattern, replacement, file_pattern='.*', file_antipattern=r'.*?\.git'):
    'replace occurrences of pattern in current folder'
    for root, dirs, files in os.walk('.'):
        for i in files:
            path = os.path.relpath(os.path.join(root, i))
            if not re.match(file_pattern, path): continue
            if re.match(file_antipattern, path): continue
            try:
                with open(path) as file: contents = file.read()
            except Exception as e:
                continue
            contents, replacements = re.subn(pattern, replacement, contents)
            if not replacements: continue
            with open(path, 'w') as file: file.write(contents)
            print(f'made {replacements} replacement(s) in {path}')

_convenience_time = _SubSection()

def timestamp(ambiguous=True, when=None):
    if when == None: when = datetime.datetime.now()
    format = '{:%Y-%m'
    if not ambiguous: format += '-%b'
    format += '-%d %H:%M:%S.%f}'
    return format.format(when).lower()

def wait(seconds):
    'wait for specified number of seconds'
    import time
    time.sleep(float(seconds))

_convenience_encoding = _SubSection()

def print_hex(file_name):
    'print specified file in hex'
    with open(file_name, 'rb') as file: bytes = file.read()
    for i in range(len(bytes)):
        print('{:02x}'.format(ord(bytes[i])), end=' ')
        if i%4 == 3: print(end=' ')
        if i%16 == 15: print()
    print()

def json():
    'take json from clipboard and pretty print'
    j = _clipboard_paste(stdout=True)
    import json
    pprint.pprint(json.loads(j))

def sql():
    'take sql from clipboard and pretty print'
    split = _clipboard_paste(stdout=True).strip().split()
    breaks = {
        'SELECT': 0,
        'FROM': 0,
        'JOIN': 1,
        'LEFT': 1,
        'RIGHT': 1,
        'FULL': 1,
        'INNER': 1,
        'OUTER': 1,
        'WHERE': 0,
        'AND': 1,
        'GROUP': 0,
        'ORDER': 0,
        'LIMIT': 0,
    }
    result = []
    broke = False
    for token in split:
        if token.upper() in breaks:
            if not broke:
                result.append('\n'+'\t'*breaks[token.upper()])
            else:
                result.append(' ')
            broke = True
        else:
            result.append(' ')
            broke = False
        result.append(token)
    print(''.join(result))

def base64():
    'take base64 from clipboard and print'
    x = _clipboard_paste(stdout=True)
    import base64
    print(base64.b64decode(x))

def unix_timestamp():
    'take unix timestamp from clipboard and print human-readable'
    t = _clipboard_paste(stdout=True)
    try:
        t = datetime.datetime.fromtimestamp(int(t))
    except:
        t = datetime.datetime.fromtimestamp(int(t) / 1000)
    print(t.isoformat())
    t = t.astimezone(datetime.timezone.utc)
    print(t.isoformat())

_convenience_navigation = _SubSection()

def find(regex, n=None, flags='i'):
    '''\
find files and directories matching regex within current directory
if n is specified, print only the nth file that matches'''
    if n != None: n = int(n)
    flags = functools.reduce(lambda a, b: a|b, [getattr(re, flag.upper()) for flag in flags])
    count = 0
    for root, dirs, files in os.walk('.'):
        for base in dirs+files:
            path = os.path.join(root, base)
            if re.search(regex, path, flags):
                count += 1
                if n == None or count == n:
                    print(path)
                    if count == n: break
        else: continue
        break

def walk(command):
    'walk current path, invoking command on each file'
    paths = []
    for dirpath, dirnames, filenames in os.walk('.'):
        for filename in filenames:
            paths.append(os.path.join(dirpath, filename))
    for path in sorted(paths):
        _invoke('{} "{}"'.format(command, path))

def regex(pattern, file_name):
    r'''find regex in file
use \\ to split pattern across lines'''
    pattern = pattern.split(r'\\')
    with open(file_name) as file: lines = file.readlines()
    for i in range(len(lines)):
        for j in range(len(pattern)):
            if not re.search(pattern[j], lines[i+j]): break
        else:
            if len(pattern) == 1:
                print('{}@{}: {}'.format(file_name, i+1, lines[i].rstrip()))
            else:
                print('{}@{}:'.format(file_name, i+1))
                for j in range(len(pattern)): print(lines[i+j].rstrip())
                print('')

def last(path):
    'print last item in directory'
    print(sorted(glob.glob(f'{path}/*'))[-1])

def bookmark_set(name):
    'bookmark current directory under specified name'
    with open(_scripts_path('dan-bookmarks.txt'), 'a') as file:
        file.write('{} {}\n'.format(name, os.getcwd()))

def bookmark_get(name=None):
    '''\
print bookmark corresponding to specified name
leave args empty to see list of bookmarks'''
    possibilities = {}
    all = {}
    with open(_scripts_path('dan-bookmarks.txt')) as file:
        for line in file.readlines():
            i, j = line.split()
            if name and i.startswith(name): possibilities[i] = j
            all[i] = j
    if len(possibilities) == 0: pprint.pprint(all); return
    print(min(possibilities.items(), key=lambda i: len(i[0]))[1])

def rename_tab(name):
    print('\x1b]2;{}\a'.format(name))

def rename_tab_and_open(program, path=''):
    if not int(os.environ.get('DAN_TAB_NAME_KEEP', 0)):
        tab_name = path
        while len(tab_name) > 24:
            split = tab_name.split('/')
            if len(split) == 1:
                tab_name = split[0][:21] + '...'
                break
            split.pop(0)
            tab_name = '/'.join(split)
        rename_tab(tab_name)
    _invoke('{} {}'.format(program, path))

def rename_tab_pwd(sides=None, separator=' '):
    name = os.path.basename(os.path.abspath(os.getcwd()))
    if sides:
        name = sides + separator + name + separator + sides
    rename_tab(name)

def link(link, linked):
    'create symlink'
    _invoke('ln -s {} {}'.format(linked, link))

def alias(name, command):
    'create a semipermanent alias'
    with open(_scripts_path('dan-aliases.txt'), 'a') as file:
        file.write('alias {}={}\n'.format(name, command))

_convenience_useful_forgettable_tools = _SubSection()

def disk_usage():
    try:
        _invoke('ncdu')
        return
    except Exception as e: print(e)
    print('ncdu failed, resorting to df')
    _invoke('df -h')

def monitor(): _invoke('top')

def network_discover(): _invoke('avahi-discover')

def user_bin_path(): _invoke('systemd-path user-binaries')

_convenience_ssh = _SubSection()

def ssh_save(name):
    shutil.copytree(_home_path('.ssh'), _home_path('.ssh-'+name))

def ssh_list():
    print([i.split('ssh-')[-1] for i in glob.glob(_home_path('.ssh-*'))])

def ssh_load(name):
    shutil.rmtree(_home_path('.ssh'), True)
    name = _home_path('.ssh-'+name)
    shutil.copytree(name, _home_path('.ssh'))

def ssh_keygen():
    _invoke('ssh-keygen -t ed25519')

_convenience_git = _SubSection()

def gcaapf():
    'git add and amend commit, then force push'
    _invoke('git commit -a --amend --no-edit')
    _invoke('git pf')

def gsmu():
    'git update submodules to latest, and sync their submodules'
    _invoke('git submodule update --remote')
    _invoke('git submodule foreach "git submodule update --init --recursive"')

def grbo():
    'git remote branch owners (most recent committers)'
    b = _invoke('git ls-remote -qh', stdout=True).splitlines()
    b = [i.split()[1][len('refs/heads/'):] for i in b]
    results = []
    for i in b:
        rev = 'origin/'+i
        split = 'vlkaeiwhvi4uhlksajhdvkausdhv'
        author, date = _invoke('git show -q --pretty="format:%an{}%ai" {}'.format(split, rev), stdout=True).split(split)
        results.append((rev, author, date))
    results = sorted(results, key=lambda x: x[2])
    a = str(max([len(i[0]) for i in results]))
    b = str(max([len(i[1]) for i in results]))
    for i in results:
        print(('{:'+a+'} {:'+b+'} {}').format(*i))

def gfor(commit, invocation):
    'run specified invocation on each commit from HEAD to specified commit'
    log = _invoke('git log --graph --pretty="%h %an" {}..HEAD'.format(commit), stdout=True).splitlines()
    for line in log:
        print(line)
        m = re.match('[| *]* ([^ ]+)', line)
        if not m: continue
        commit = m.group(1)
        _invoke('git checkout {}'.format(commit))
        _invoke(invocation)

def grecent():
    'show recent commits in repos in current directory'
    for i in os.listdir('.'):
        os.chdir(i)
        if os.path.exists('.git'):
            log = _invoke('git log --graph --pretty="%h a:%ai c:%ci %s" --since="1 day ago"', stdout=True)
            if log:
                print(i)
                print(log)
        os.chdir('..')

_convenience_inlining = _SubSection()

def shell(*args):
    _invoke(' '.join(args))

def invoke(invocation, *args):
    'invocation with python-style substitutions'
    _invoke(invocation.format(*args))

def python():
    'run python code from stdin; useful in vim `:w !dan python`'
    with open(_tmp_path('tmp.py'), 'w') as f:
        f.write(stdin)
    _invoke('python3 {}'.format(_tmp_path('tmp.py')))

def php():
    'run php code from stdin; useful in vim `:w !dan php`'
    with open(_tmp_path('tmp.php'), 'w') as f:
        f.write('<?php\n')
        f.write(stdin)
    _invoke('php -f {}'.format(_tmp_path('tmp.php')))

def cc():
    'run c code from stdin; useful in vim `:w !dan cc`'
    with open(_tmp_path('tmp.c'), 'w') as f:
        f.write('#include <math.h>\n')
        f.write('#include <stdio.h>\n')
        f.write('#include <stdlib.h>\n')
        f.write('#include <time.h>\n')
        if 'main' not in stdin: f.write('int main(){')
        f.write(stdin)
        if 'main' not in stdin: f.write('}')
    _invoke('gcc -o {} {}'.format(_tmp_path('tmp'), _tmp_path('tmp.c')))
    _invoke(_tmp_path('tmp'))

def cpp():
    'run c++ code from stdin; useful in vim `:w !dan cpp`'
    obvious_path = os.path.expanduser('~/Desktop/repos/obvious/cpp/obvious.hpp')
    with open(_tmp_path('tmp.cpp'), 'w') as f:
        f.write('#include <cmath>\n')
        f.write('#include <cstdlib>\n')
        f.write('#include <ctime>\n')
        f.write('#include <fstream>\n')
        f.write('#include <iostream>\n')
        f.write('#include <map>\n')
        f.write('#include <set>\n')
        f.write('#include <sstream>\n')
        f.write('#include <thread>\n')
        f.write('#include <vector>\n')
        if os.path.exists(obvious_path):
            f.write('#include "{}"\n'.format(obvious_path))
        f.write('using namespace std;\n')
        if 'main' not in stdin: f.write('int main(){')
        f.write(stdin)
        if 'main' not in stdin: f.write('}')
    _invoke('g++ -o {} {}'.format(_tmp_path('tmp'), _tmp_path('tmp.cpp')))
    _invoke(_tmp_path('tmp'))

def rust():
    'run rust code from stdin; useful in vim `:w !dan rust`'
    global stdin
    if 'fn main(' not in stdin:
        stdin = 'fn main() {' + stdin + '}'
    with open(_tmp_path('tmp.rs'), 'w') as f:
        f.write(stdin)
    _invoke('rustc -o {} {}'.format(_tmp_path('tmp'), _tmp_path('tmp.rs')))
    _invoke(_tmp_path('tmp'))

def rustex():
    'print rust expression from stdin; useful in vim `:w !dan rust`'
    global stdin
    with open(_tmp_path('tmp.rs'), 'w') as f:
        f.write('fn main() { println!("{:?}", ' + stdin + '); }')
    _invoke('rustc -o {} {}'.format(_tmp_path('tmp'), _tmp_path('tmp.rs')))
    _invoke(_tmp_path('tmp'))

def cargo():
    'like `rust` but allows crate dependencies to be specified as well -- use `//deps dep1 dep2`'
    os.chdir(_tmp_path())
    if not os.path.exists('cargo'):
        _invoke('cargo new cargo')
    os.chdir('cargo')
    with open('Cargo.toml') as f:
        cargo = f.read()
    deps = []
    global stdin
    for line in stdin.splitlines():
        if line.startswith('//deps'):
            deps.extend(line.split()[1:])
    cargo = re.sub(
        r'\[dependencies\].*',
        '\n'.join(
            ['[dependencies]']
            +
            [i + ' = "*"' for i in deps]
        ),
        cargo,
        flags=re.DOTALL,
    )
    with open('Cargo.toml', 'w') as f:
        f.write(cargo)
    if 'fn main(' not in stdin:
        stdin = 'fn main() {' + stdin + '}'
    with open(os.path.join('src', 'main.rs'), 'w') as f:
        f.write(stdin)
    _invoke('cargo run')

_convenience_misc = _SubSection()

def tab(cmd='echo hello'):
    'create a terminal tab and run supplied command'
    _invoke(f"DAN_START_CMD='{cmd}' gnome-terminal --tab")

def browser(url):
    webbrowser.open(url)

def dan(*args):
    'invoke this script on each arg in order'
    ' -- useful for creating compound statements, for example in an alias'
    for arg in args: _invoke('dan '+arg)

def pyre(pattern):
    'run python re.search on each line of stdin, print matches'
    for line in stdin.splitlines():
        if m := re.search(pattern, line):
            print(line)

def hista():
    '''\
Print out a command that will immediately update history on mac.
So you'd use it like `dan hista`.
history doesn't work right, seemingly because it's a builtin.'''
    print('history -w {}'.format(_home_path('.bash_history')))

def password(special_chars='!@#$%&*'):
    print(''.join(
        secrets.choice(string.ascii_letters + string.digits + special_chars)
        for i in range(32)
    ))

def eol():
    for root, dirs, file_names in os.walk(os.getcwd()):
        for file_name in file_names:
            path = os.path.join(root, file_name)
            print(path)
            with open(path) as file:
                try:
                    if '\r\n' in file.read():
                        print(_Emoji.neutral+'DOS line endings detected!')
                except:
                    print(_Emoji.explode+'Exception while checking')

def lint():
    'Lint whatever is in the current directory.'
    if os.path.exists('Cargo.toml'):
        _invoke('cargo fmt')
        _invoke('cargo clippy')

_crypto = _Section()

def crypto_generate_key_pair():
    subprocess.run(['gpg', '--generate-key'])

def crypto_export_public(user=None):
    if not user:
        subprocess.run(['gpg', '--export', '--armor', '-o', 'dan_pub.pgp'])
    else:
        subprocess.run(['gpg', '--export', '--armor', '-o', f'{user}_pub.pgp', user])

def crypto_export_private():
    subprocess.run(['gpg', '--export-secret-key', '--armor', '-o', 'dan_priv.pgp'])

def crypto_import(file_name):
    subprocess.run(['gpg', '--import', file_name])

def crypto_list_public_keys():
    subprocess.run(['gpg', '-k'])

def crypto_encrypt(file_name=None):
    if file_name == None:
        print('file?')
        file_name = input()
    print('----- listing public keys -----')
    subprocess.run(['gpg', '-k'])
    print('----- encrypting -----')
    subprocess.run(['gpg', '-e', file_name])

def crypto_decrypt(file_name):
    subprocess.run(['gpg', file_name])

def cert_summary(path):
    subprocess.run(['openssl', 'x509', '-text', '-in', path])

_aws = _Section()

def s3_download(path):
    bucket, key = re.match('s3://([^/]+)/(.+)', path).groups()
    outfile = key.split('/')[-1]
    subprocess.run(f'aws s3api get-object --bucket {bucket} --key {key} {outfile}'.split())

_setup = _Section()

_bash_profile_appendage = r'''

{header}
#DAN_PS1_UNIQUIFIER=""
python3 {this} bash
source {dan_bash_path}

# pyenv
export PYENV_VERSION=3.9.6
export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/bin:$PATH"
#eval "$(pyenv init --path)"

# rust
#source ~/.cargo/env

# nvm
# experiment - `cd ~ && clone https://github.com/nvm-sh/nvm .nvm` and then uncomment these lines to avoid curl | bash
#export NVM_DIR="$HOME/.nvm"
#[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
#[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
#===== end dan =====#

'''

def install_self():
    'hook into bash init script'
    if platform.system() != 'Windows':
        #find bash init script
        bash_init = None
        if os.path.exists(_home_path('.bash_profile')): bash_init = _home_path('.bash_profile')
        elif os.path.exists(_home_path('.bashrc')): bash_init = _home_path('.bashrc')
        if not bash_init:
            print("couldn't find a bash init script!")
            sys.exit(1)
        #append if not already done
        header = "#===== appended by dan from dansgithubuser's playground =====#"
        already_done = False
        with open(bash_init, 'r') as file:
            for line in file.readlines():
                if header in line:
                    already_done = True
                    break
        if not already_done:
            print('I will append to {} and make it use my bash command -- if that is OK, enter y'.format(bash_init))
            if _input() != 'y': sys.exit(1)
            with open(bash_init, 'a') as file:
                file.write(_bash_profile_appendage.format(
                    header=header,
                    this=this,
                    dan_bash_path=_home_path('Desktop/scripts/dan-bash.sh'),
                ))
    else:
        for root, dirs, files in os.walk(_this_path('windows-portable')):
            for file in files:
                path = os.path.join(root, file)
                shutil.copy(path, path[:-len('.disguise')])
        with open(_scripts_path('init.bat'), 'w') as file: file.write(rf'@PATH=%PATH%;{_scripts_path()};{_this_path("windows-portable")}')
        with open(_scripts_path('dan.bat'), 'w') as file: file.write(f'python {this} %*')
        _invoke(r'reg add "HKCU\Software\Microsoft\Command Processor"'
            ' /v AutoRun ^'
            ' /t REG_EXPAND_SZ'
            f''' /d "{_scripts_path('init.bat')}"'''
            ' /f'
        )
    #other stuff
    vi()
    git()
    enable_sysrq()

def bash():
    'update bash setup, writes to ~/Desktop/scripts/'
    try: os.makedirs(_scripts_path(''))
    except: pass
    shutil.copy(this, _scripts_path(''))
    with open(_scripts_path('dan-bash.sh'), 'w') as file: file.write(_dan_bash)
    if all([
        platform.system() == 'Linux',
        int(os.environ.get('DAN_DISABLE_CAPSLOCK', '1')),
        not os.environ.get('SSH_CLIENT'),
    ]):
        disable_capslock()

_vimrc = r'''
set autoindent " apply indentation of previous line to new line
set number " line numbers
set list " show whitespace
set listchars=tab:>- " show tabs non-disgustingly
set ignorecase " case-insensitive matching lowercase pattern
set smartcase " case-sensitive matching otherwise
set noswapfile " swap files screw up lots of other software
set path+=** " :find recursively in current directory
" "very magic" ie use regex, normal mode non-recursive map
nnoremap / /\v
" same in visual and select modes
vnoremap / /\v
set fdm=indent " set fold method and fold everything
autocmd BufWinEnter * normal zR " unfold everything

" helpers
function SpacesForIndent(n)
    setlocal expandtab
    let &tabstop=a:n
    let &softtabstop=a:n
    let &shiftwidth=a:n
endfunction

" infer particular settings from contents of file
function SettingsForContent()
    " Determines whether to use spaces or tabs on the current buffer.
    if getfsize(bufname("%")) > 256000
        " File is very large, just use the default.
        " Turn off syntax highlighting too!
        setlocal syntax=off
        return
    endif

    let numTabs=len(filter(getbufline(bufname("%"), 1, 250), 'v:val =~ "^\t"'))
    let num2Spaces=len(filter(getbufline(bufname("%"), 1, 250), 'v:val =~ "^  [^ ]"'))
    let num4Spaces=len(filter(getbufline(bufname("%"), 1, 250), 'v:val =~ "^    [^ ]"'))

    if max([num2Spaces, num4Spaces]) > numTabs
        if num2Spaces > 0
            call SpacesForIndent(2)
        else
            call SpacesForIndent(4)
        endif
    elseif numTabs > 0
        setlocal noexpandtab
    endif
endfunction
autocmd BufReadPost * call SettingsForContent()

" semantic highlighting
autocmd BufEnter * :syntax sync fromstart
autocmd BufEnter * :let g:semanticUseBackground = 1
" press comma s to toggle semantic highlighting
nnoremap ,s :SemanticHighlightToggle<cr>

" settings for file types
let ext=expand('%:e')
if index(["py", "md", "rs"], ext)!=-1
    call SpacesForIndent(4)
elseif index(["html", "css", "js", "vue"], ext)!=-1
    call SpacesForIndent(2)
elseif index(["c", "h", "cpp", "hpp"], ext)!=-1
    setlocal tabstop=2
    setlocal shiftwidth=2
endif

" navigating splits without ctrl-w
nnoremap ,h :wincmd h<CR>
nnoremap ,l :wincmd l<CR>
nnoremap ,j :wincmd j<CR>
nnoremap ,k :wincmd k<CR>

" tree view for builtin explorer
let g:netrw_liststyle = 3
let g:netrw_banner = 0

" vim-plug
"let data_dir = has('nvim') ? stdpath('data') . '/site' : '~/.vim'
"if empty(glob(data_dir . '/autoload/plug.vim'))
"  silent execute '!curl -fLo '.data_dir.'/autoload/plug.vim --create-dirs  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
"  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
"endif
"
"call plug#begin()
"Plug 'prabirshrestha/vim-lsp'
"Plug 'mattn/vim-lsp-settings'
"call plug#end()
"filetype indent off
"
"nnoremap ,d :LspDef<CR>
"
"let g:lsp_diagnostics_highlights_enabled = 0
"let g:lsp_diagnostics_signs_enabled = 0
"nnoremap ,,diag :LspDocumentDiagnostics<CR>
"
"let g:lsp_settings_enable_suggestions = 0
"
"let g:lsp_auto_enable = 0
"let g:dan_lsp_enabled = 0
"function ToggleLsp()
"  if g:dan_lsp_enabled
"    call lsp#disable()
"    let g:dan_lsp_enabled = 0
"  else
"    call lsp#enable()
"    let g:dan_lsp_enabled = 1
"  endif
"endfunction
"nnoremap ,,lsp :call ToggleLsp()<CR>
'''

def vi():
    'setup vi stuff'
    p = _home_path('.vimrc')
    print('Installing vim-gui-common.')
    _invoke('sudo apt install -y vim-gui-common')
    print('I will create a vimrc file.')
    if os.path.exists(p): print('I will overwrite the existing one.')
    print('If that is OK, enter y.')
    if _input() != 'y': sys.exit(1)
    with open(p, 'w') as file: file.write(_vimrc)
    if platform.system() == 'Windows':
        with open(_scripts_path('vi.bat'), 'w') as file:
                file.write(r'"C:\Program Files\Git\usr\bin\vim" %*')
    plugins_path = _home_path('.vim/pack/vendor/start')
    os.makedirs(plugins_path, exist_ok=True)
    invoke(f'git clone https://github.com/jaxbot/semantic-highlight.vim.git {plugins_path}/semantic-highlight.vim')

def git():
    'update git aliases, download git-completion.bash, set conflict style to diff3'
    with open(_this_path('git-aliases.txt')) as file:
        for line in file.readlines():
            if platform.system() == 'Windows':
                if 'alias.sf' in line: continue
            _invoke(line)
    if platform.system() != 'Windows':
        print('Installing curl.')
        _invoke('sudo apt install -y curl')
        _invoke('curl https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash > ~/git-completion.bash')
    _invoke('git config --global merge.conflictstyle diff3')

def pyenv():
    print('cloning pyenv repos into ~/.pyenv')
    _invoke('git clone https://github.com/pyenv/pyenv.git            ~/.pyenv')
    _invoke('git clone https://github.com/pyenv/pyenv-doctor.git     ~/.pyenv/plugins/pyenv-doctor')
    _invoke('git clone https://github.com/pyenv/pyenv-update.git     ~/.pyenv/plugins/pyenv-update')
    _invoke('git clone https://github.com/pyenv/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv')
    print('apt update')
    _invoke('sudo apt update')
    print('installing python build requirements')
    _invoke(' '.join([
        'sudo apt install -y',
        'make',
        'build-essential',
        'libssl-dev',
        'zlib1g-dev',
        'libbz2-dev',
        'libreadline-dev',
        'libsqlite3-dev',
        'wget',
        'curl',
        'llvm',
        'libncursesw5-dev',
        'xz-utils',
        'tk-dev',
        'libxml2-dev',
        'libxmlsec1-dev',
        'libffi-dev',
        'liblzma-dev',
    ]))
    print('Your turn! Uncomment appropriate line in `~/.bashrc` and install your preferred version.')

def disable_capslock():
    _invoke('xmodmap -e "keycode 66 = Shift_L NoSymbol Shift_L"')

def enable_sysrq():
    _invoke("sudo sh -c 'echo kernel.sysrq=1>>/etc/sysctl.d/99-sysctl.conf'")

def ssh_server():
    _invoke('sudo su -c "apt install -y openssh-server; systemctl enable ssh; systemctl restart ssh"')

_esoteric = _Section()

def _getmtime(path):
    return timestamp(False, datetime.datetime.fromtimestamp(os.path.getmtime(path)))

def getmtime(path):
    'get modified time of specified path'
    print('{} {}'.format(_getmtime(path), path))

def _exif(path, key):
    import exifread
    with open(path, 'rb') as file: tags = exifread.process_file(file)
    if key == '*': return tags
    return tags.get(key, None)

def exif(path, key='*'):
    'get exif data from path'
    if key == '*':
        import pprint
        pprint.pprint(_exif(path, '*'))
    print('{} {}'.format(_exif(path, key), path))

def google_photos_time(path):
    'get creation time of image downloaded from google photos (?)'
    x = _exif(path, 'Image DateTime')
    if x:
        x = timestamp(False, datetime.datetime(*[int(i) for i in re.split(':| ', x.values)]))
    else: x = _getmtime(path) or '?'
    print('{}\t{}'.format(x, path))

def lines_run_length(pattern='.*'):
    previous = None
    body = []
    def p():
        if not body: return
        print('{:6} {}'.format(len(body), previous))
        for i in body: print('\t'+i)
    def e(l):
        return re.match(pattern, l).group(0)
    for line in lines:
        line = line.strip()
        if e(line) != previous:
            p()
            body = []
        previous = e(line)
        body.append(line)
    p()

_conservative_logrotate_conf = '''size 1M
rotate 0
create
include /etc/logrotate.d
/var/log/wtmp {
    missingok
    monthly
    create 0664 root utmp
    rotate 1
}

/var/log/btmp {
    missingok
    monthly
    create 0660 root utmp
    rotate 1
}
'''

_conservative_rsyslog = '''/var/log/syslog
{
    rotate 0
    size 1M
    missingok
    postrotate
        invoke-rc.d rsyslog rotate > /dev/null
    endscript
}

/var/log/mail.info
/var/log/mail.warn
/var/log/mail.err
/var/log/mail.log
/var/log/daemon.log
/var/log/kern.log
/var/log/auth.log
/var/log/user.log
/var/log/lpr.log
/var/log/cron.log
/var/log/debug
/var/log/messages
{
    rotate 0
    size 1M
    missingok
    sharedscripts
    postrotate
        invoke-rc.d rsyslog rotate > /dev/null
    endscript
}
'''

def conservative_logrotate():
    _check()
    with open('/etc/logrotate.conf') as file: file.write(_conservative_logrotate_conf)
    with open('/etc/logrotate.d/rsyslog') as file: file.write(_conservative_rsyslog)

def rm_crash_dumps():
    'remove files that cause ubuntu to ask you if you want to report a detected problem'
    _invoke('sudo rm /var/crash/*')

def static_ip():
    '''\
Useful for connecting to wrt54gl running openwrt 
in failsafe mode (hold reset, power on, wait ~10s until dmz lights up, let go, see power and dmz lights flash, connect with `telnet 192.168.1.1`) 
or if its DHCP is disabled and its IP is x.x.1.x. 
If the IP is something else, make sure the 3rd numbers match in the command below.'''
    _check()
    _invoke('sudo ifconfig enp1s0 192.168.1.3 netmask 255.255.255.0')

def naive_bracket_format(indent_size=2):
    'take input from clipboard and print with indentation based on parens, brackets, and braces'
    x = _clipboard_paste(stdout=True)
    indent = 0
    print_spaces = True
    for i in x:
        if i in '([{':
            print(i)
            indent += indent_size
            print(' ' * indent, end='')
            print_spaces = False
        elif i in ')]}':
            print('')
            indent -= indent_size
            print(' ' * indent, end='')
            print(i, end='')
        elif i == ' ':
            if print_spaces:
                print(i, end='')
        else:
            print(i, end='')
            print_spaces = True

def lat_lon_distance(lat_0, lon_0, *lat_lon_i):
    lat_to_meters = 2 * math.pi / 360 * 6378000;
    lat_0 = float(lat_0)
    lon_0 = float(lon_0)
    aspect = math.cos(lat_0 / 360 * 2 * math.pi)
    for i in range(0, len(lat_lon_i), 2):
        dy = (lat_0 - float(lat_lon_i[i+0])) * lat_to_meters
        dx = (lon_0 - float(lat_lon_i[i+1])) * lat_to_meters * aspect
        print(math.sqrt(dy * dy + dx * dx))

def cron_add():
    print('What is the name of this job?')
    name = input()
    print()
    print('I will ask about the minute, hour, day-of-month, month, and day-of-week this job should run at.')
    print('Here are the special symbols you can use:')
    print(
        '\t* any value\n'
        '\t, value list separator\n'
        '\t- range of values\n'
        '\t/ step values\n'
    )
    print('On which minute should this task run? (0-59)')
    minute = input() or '*'
    print('On which hour should this task run? (0-23)')
    hour = input() or '*'
    print('On which day of the month should this task run? (1-31)')
    day_m = input() or '*'
    print('On which month should this task run? (1-12)')
    month = input() or '*'
    print('On which day of the week should this task run? (0-6)')
    day_w = input() or '*'
    print()
    print('I will open a web page to review. Enter to continue. s to skip.')
    i = input()
    if i != 's':
        webbrowser.open(f'https://crontab.guru/#{minute}_{hour}_{day_m}_{month}_{day_w}')
        print('Enter to confirm and continue, ctrl-c to abort.')
        input()
    print()
    print('What user should this job run under?')
    user = input()
    print()
    print('What is the command?')
    command = input()
    print()
    line = f'{minute} {hour} {day_m} {month} {day_w} {user} {command}'
    file_path = f'/etc/cron.d/{name}'
    print('I will put')
    print('\t' + line)
    print('into')
    print('\t' + file_path)
    print('Enter to continue, ctrl-c to abort.')
    input()
    if os.access('/etc/cron.d', os.W_OK):
        with open(file_path, 'w') as f:
            f.write(line)
    else:
        _invoke(f'''sudo sh -c "echo '{line}' > {file_path}"''')

_help = _Section()

def _get_commands():
    return sorted(
        [i for i in globals() if callable(eval(i)) and not i.startswith('_')],
        key=lambda x: inspect.getsourcelines(eval(x))[1],
    )

def h(command=None):
    'help'
    if command == None:
        sections = sorted(
            [i for i in globals() if isinstance(eval(i), _Section)],
            key=lambda x: eval(x).line
        )
        section = 0
        commands = _get_commands()
        max_len_command = max([len(i) for i in commands])
        for command in commands:
            while section < len(sections) and inspect.getsourcelines(eval(command))[1] > eval(sections[section]).line:
                title = sections[section][1:]
                if isinstance(eval(sections[section]), _SubSection):
                    line_char = '-'
                    title = ' '.join(title.split('_')[1:])
                else:
                    line_char = '='
                line = line_char * max_len_command
                print(f'\n{line} {title} {line}')
                section += 1
            full_help = inspect.getdoc(eval(command))
            if full_help:
                full_help = full_help.splitlines()
                short_help = full_help[0]
                if len(full_help) > 1: short_help += '...'
            else: short_help = ''
            print(('{:>'+str(max_len_command)+'}  {}').format(command, short_help))
    else:
        print(inspect.getdoc(eval(command)))
        print(inspect.getfullargspec(eval(command)))

help = h

def vi_notes():
    invoke(f'vi {_home_path("Desktop/repos/playground/notes/vi.md")}')

#=====main=====#
parser = argparse.ArgumentParser(description='`dan h` to list commands, `dan h command` for help with specific command')
parser.add_argument('--dry', action='store_true', help='only print invocations')
parser.add_argument('-i', action='store_true',
    help='take a Python iterable from stdin and run command on each item')
parser.add_argument('-l', action='store_true',
    help='take lines from stdin and run command on each')
parser.add_argument('--quiet', '-q', action='store_true')
parser.add_argument('--force', '-f', action='store_true', help='bypass checks for system-altering commands')
parser.add_argument('command')
parser.add_argument('args', nargs='*', help='use {} to sub stdin')
if len(sys.argv) == 1: h()
args = parser.parse_args()

if not args.quiet:
    sys.stderr.write(f'invoked as {getpass.getuser()} with: {sys.argv}\n')

def _translate_lazy(lazy, possibilities):

    def equal():
        return [i for i in possibilities if i == lazy]

    def prefix():
        return [i for i in possibilities if i.startswith(lazy)]

    def consecutive_with_ends():
        cond = lambda i: all([
            re.search('.*'.join(lazy), i),
            i.startswith(lazy[0]),
            i.endswith(lazy[-1]),
        ])
        return [i for i in possibilities if cond(i)]

    def consecutive_with_first():
        return [i for i in possibilities if re.search('.*'.join(lazy), i) and i.startswith(lazy[0])]

    def consecutive():
        return [i for i in possibilities if re.search('.*'.join(lazy), i)]

    strategies = [
        equal,
        prefix,
        consecutive_with_ends,
        consecutive_with_first,
        consecutive,
    ]

    for strategy in strategies:
        candidates = strategy()
        if len(candidates) == 1:
            result = possibilities[candidates[0]]
            if lazy != result.__name__:
                print(f'{lazy} interpreted as {result.__name__}')
            return result
    for strategy in strategies:
        print(strategy.__name__, 'candidates:', ' '.join(strategy()))
    raise Exception(f'''Couldn't resolve "{lazy}".''')

try:
    #if you read from stdin with no input, run blocks for input
    #this is the best way I could find to check for input
    if not sys.stdin.isatty():
        stdin = sys.stdin.read()
    else:
        stdin = ''
    def _ex(args, stdin):
        commands = _get_commands()
        f = _translate_lazy(args.command, {i: eval(i) for i in commands})
        if stdin:
            result = f(*[i.format(stdin) for i in args.args])
        else:
            result = f(*args.args)
        if result: print(result)
    if args.i:
        outer_stdin = stdin
        del stdin
        for stdin in eval(outer_stdin):
            _ex(args, stdin)
    elif args.l:
        outer_stdin = stdin
        del stdin
        for stdin in outer_stdin.splitlines():
            _ex(args, stdin)
    else: _ex(args, stdin)
except TypeError: h(args.command); raise
