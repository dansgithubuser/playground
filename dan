#!/usr/bin/env python

from __future__ import print_function

import argparse, datetime, os, platform, pprint, re, shutil, subprocess, sys

sys.stderr.write('invoked with: {}\n'.format(sys.argv))

try: input=raw_input
except: pass

this=os.path.realpath(__file__)

def timestamp(ambiguous=True, when=None):
	if when==None: when=datetime.datetime.now()
	format='{:%Y-%m'
	if not ambiguous: format+='-%b'
	format+='-%d %H:%M:%S.%f}'
	return format.format(when).lower()

def _home_path(path): return os.path.join(os.path.expanduser('~'), *path.split('/'))
def _this_path(path): return os.path.join(os.path.split(this)[0], *path.split('/'))
def _scripts_path(path): return _home_path('Desktop/scripts/'+path)

def _invoke(invocation):
	if args.dry: print(invocation)
	else: subprocess.check_call(invocation, shell=True)

def _platform_invoke(linux=None, darwin=None, windows=None):
	if   platform.system()=='Linux'  : _invoke(linux)
	elif platform.system()=='Darwin' : _invoke(darwin)
	elif platform.system()=='Windows': _invoke(windows)

opener=None
if   not subprocess.call('which xdg-open>/dev/null', shell=True): opener='xdg-open'
elif not subprocess.call('which open    >/dev/null', shell=True): opener='open'
if not opener and platform.system()=='Windows': opener='explorer'

_dan_bash='''force_color_prompt=yes
PATH=$PATH:~/Desktop/scripts
PS1='\\e[0;37;44m               $?               \\e[m \n\\h \\t \\w$ '
alias o="{} ."
if ! ps -e | grep xbindkeys > /dev/null; then xbindkeys; fi
echo "dan bash ran"
'''.format(opener)

if os.path.exists(_scripts_path('dan-aliases.txt')):
	with open(_scripts_path('dan-aliases.txt')) as file:
		_dan_bash+=file.read()

def bash():
	'update bash setup, writes to ~/Desktop/scripts/'
	try: os.makedirs(_scripts_path(''))
	except: pass
	shutil.copy(this, _scripts_path(''))
	with open(_scripts_path('dan-bash.sh'), 'w') as file: file.write(_dan_bash)

def sleep(type=None):
	if type=='deep':
		for i in [
			'LID0',
			'SLPB',
			'UHC0',
			'UHC1',
			'UHC2',
			'UHC3',
			'UHC4',
			'UHCR',
			'EHC1',
			'EHC2',
		]:
			_invoke('sudo sh -c "echo {} > /proc/acpi/wakeup"'.format(i))
	_invoke('systemctl suspend')

def reboot(): _invoke('reboot')

def off(): _platform_invoke('sudo poweroff', 'sudo halt')

def link(link, linked):
	_invoke('ln -s {} {}'.format(linked, link))

def find(name):
	'find file with name within current directory'
	_invoke('find . -name {}'.format(name))

def vu():
	'volume up'
	_invoke('pactl -- set-sink-volume 0 +10%')

def vd():
	'volume down'
	_invoke('pactl -- set-sink-volume 0 -10%')

def _brightness(level):
	path='/sys/class/backlight/intel_backlight/brightness'
	if level=='get':
		with open(path) as file:
			return int(file.read())
	_invoke('echo {}|sudo tee {}'.format(int(level), path))

def b(level):
	'set brightness'
	if level=='get': return (_brightness('get')-5000)/1000.0
	_brightness(int(float(level)*1000+5000))

def bu():
	'brightness up'
	b(b('get')*2)

def bd():
	'brightness down'
	b(b('get')//2)

def i(command):
	'append a note of this command to Desktop/dan-install.txt'
	with open(_home_path('Desktop/dan-install.txt'), 'a') as file:
		file.write(timestamp(False)+'\n')
		file.write(command+'\n')
		file.write('\n')
	_invoke(command)

def install_self():
	'hook into bash init script'
	#find bash init script
	bash_init=None
	if os.path.exists(_home_path('.bash_profile')): bash_init=_home_path('.bash_profile')
	elif os.path.exists(_home_path('.bashrc')): bash_init=_home_path('.bashrc')
	if not bash_init:
		print("couldn't find a bash init script!")
		sys.exit(1)
	#append if not already done
	header="#=====appended by dan from dansgithubuser's playground=====#"
	already_done=False
	with open(bash_init, 'r') as file:
		for line in file.readlines():
			if header in line:
				already_done=True
				break
	if not already_done:
		print('I will append to {} and make it use my bash command -- if that is OK, enter y'.format(bash_init))
		if input()!='y': sys.exit(1)
		with open(bash_init, 'a') as file:
			file.write("\n\n{}\n".format(header))
			file.write('python {} bash\n'.format(this))
			file.write('source {}\n'.format(_home_path('Desktop/scripts/dan-bash.sh')))
			file.write('#=====end dan=====#\n')
	#other stuff
	vi()
	git()

_vimrc='''set autoindent
set number
set tabstop=2
set list
set nocompatible
syntax on
set pastetoggle=<F2>
set ignorecase
set backspace=indent,eol,start

"substitution with non-insane syntax
function DanFunctionSubstitute(pattern, replacement)
	execute '.,$s/'.a:pattern.'/'.a:replacement.'/gc'
endfunction
command -nargs=* Substitute call DanFunctionSubstitute(<f-args>)

colorscheme darkblue
hi Whitespace ctermfg=DarkBlue
match Whitespace /\s/

function TabsOrSpaces()
    " Determines whether to use spaces or tabs on the current buffer.
    if getfsize(bufname("%")) > 256000
        " File is very large, just use the default.
        return
    endif

    let numTabs=len(filter(getbufline(bufname("%"), 1, 250), 'v:val =~ "^\\t"'))
    let numSpaces=len(filter(getbufline(bufname("%"), 1, 250), 'v:val =~ "^ "'))

    if numTabs < numSpaces
        setlocal expandtab
        setlocal tabstop=4
    endif
endfunction

" Call the function after opening a buffer
autocmd BufReadPost * call TabsOrSpaces()

autocmd BufNewFile,BufRead *.rs set filetype=rust
autocmd FileType rust setlocal expandtab tabstop=4 softtabstop=4

autocmd BufNewFile,BufRead *.ex,*.exs set filetype=elixir
autocmd FileType elixir setlocal expandtab tabstop=2 softtabstop=2
'''

def vi():
	p=_home_path('.vimrc')
	print('I will create a .vimrc file, it requires package vim-gui-common.')
	if os.path.exists(p): print('I will overwrite the existing one.')
	print('If that is OK, enter y.')
	if input()!='y': sys.exit(1)
	with open(p, 'w') as file: file.write(_vimrc)

def git():
	'update git aliases'
	_invoke('sh '+_this_path('git-aliases.txt'))

def disk_usage(): _invoke('ncdu')

def monitor(): _invoke('top')

_conservative_logrotate_conf='''size 1M
rotate 0
create
include /etc/logrotate.d
/var/log/wtmp {
	missingok
	monthly
	create 0664 root utmp
	rotate 1
}

/var/log/btmp {
	missingok
	monthly
	create 0660 root utmp
	rotate 1
}
'''

_conservative_rsyslog='''/var/log/syslog
{
	rotate 0
	size 1M
	missingok
	postrotate
		invoke-rc.d rsyslog rotate > /dev/null
	endscript
}

/var/log/mail.info
/var/log/mail.warn
/var/log/mail.err
/var/log/mail.log
/var/log/daemon.log
/var/log/kern.log
/var/log/auth.log
/var/log/user.log
/var/log/lpr.log
/var/log/cron.log
/var/log/debug
/var/log/messages
{
	rotate 0
	size 1M
	missingok
	sharedscripts
	postrotate
		invoke-rc.d rsyslog rotate > /dev/null
	endscript
}
'''

def conservative_logrotate():
	with open('/etc/logrotate.conf') as file: file.write(_conservative_logrotate_conf)
	with open('/etc/logrotate.d/rsyslog') as file: file.write(_conservative_rsyslog)

def last(index=1):
	print(sorted([i.strip() for i in sys.stdin.read().split()])[-int(index)])

def network_discover(): _invoke('avahi-discover')

def walk(command):
	paths=[]
	for dirpath, dirnames, filenames in os.walk('.'):
		for filename in filenames:
			paths.append(os.path.join(dirpath, filename))
	for path in sorted(paths):
		_invoke('{} "{}"'.format(command, path))

def regex(pattern, file_name):
	r'''use \\ to split pattern across lines'''
	pattern=pattern.split(r'\\')
	with open(file_name) as file: lines=file.readlines()
	for i in range(len(lines)):
		for j in range(len(pattern)):
			if not re.search(pattern[j], lines[i+j]): break
		else:
			if len(pattern)==1:
				print('{}@{}: {}'.format(file_name, i+1, lines[i].rstrip()))
			else:
				print('{}@{}:'.format(file_name, i+1))
				for j in range(len(pattern)): print(lines[i+j].rstrip())
				print('')

def replace(pattern, replacement, string):
	print(re.sub(pattern, replacement, string))

def sed(pattern, replacement):
	print(re.sub(pattern, replacement, sys.stdin.read()))

def extract(pattern, string):
	x=re.match(pattern, string)
	if x: print(x.group(0))

def bookmark(name):
	with open(_this_path('dan-bookmarks.txt'), 'a') as file:
		file.write('{} {}\n'.format(name, os.getcwd()))

def g(name):
	possibilities={}
	all={}
	with open(_this_path('dan-bookmarks.txt')) as file:
		for line in file.readlines():
			i, j=line.split()
			if i.startswith(name): possibilities[i]=j
			all[i]=j
	if len(possibilities)==0: pprint.pprint(all); return
	print(min(possibilities.items(), key=lambda i: len(i[0]))[1])

def alias(name, command):
	with open(_this_path('dan-aliases.txt'), 'a') as file:
		file.write('function {}(){{\n\t{}\n}}\n\n'.format(name, command))

def ssh_save(name):
	shutil.copytree(_home_path('.ssh'), _home_path('.ssh-'+name))

def ssh_list():
	import glob
	print([i.split('ssh-')[-1] for i in glob.glob(_home_path('.ssh-*'))])

def ssh_load(name):
	shutil.rmtree(_home_path('.ssh'), True)
	name=_home_path('.ssh-'+name)
	shutil.copytree(name, _home_path('.ssh'))

def p(format, *args):
	'invoke python'
	exec(format.format(*args))

def _getmtime(path):
	return timestamp(False, datetime.datetime.fromtimestamp(os.path.getmtime(path)))

def getmtime(path):
	print('{} {}'.format( _getmtime(path), path))

def _exif(path, key):
	import exifread
	with open(path) as file: tags=exifread.process_file(file)
	if key=='*': return tags
	return tags.get(key, None)

def exif(path, key='*'):
	if key=='*':
		import pprint
		pprint.pprint(_exif(path, '*'))
	print('{} {}'.format(_exif(path, key), path))

def google_photos_time(path):
	x=_exif(path, 'Image DateTime')
	if x:
		x=timestamp(False, datetime.datetime(*[int(i) for i in re.split(':| ', x.values)]))
	else: x=_getmtime(path) or '?'
	print('{} {}'.format(x, path))

def sort():
	lines=sys.stdin.readlines()
	lines=sorted(lines)
	for line in lines: sys.stdout.write(line)

def lines_run_length(pattern='.*'):
	previous=None
	body=[]
	def p():
		if not body: return
		print('{:6} {}'.format(len(body), previous))
		for i in body: print('\t'+i)
	def e(l):
		return re.match(pattern, l).group(0)
	for line in sys.stdin.readlines():
		line=line.strip()
		if e(line)!=previous:
			p()
			body=[]
		previous=e(line)
		body.append(line)
	p()

def copy(name='clipboard'):
	with open(_scripts_path('dan-copy-'+name), 'w') as file:
		file.write(input())

def paste(name='clipboard'):
	with open(_scripts_path('dan-copy-'+name)) as file:
		sys.stdout.write(file.read())

def wait(seconds):
	import time
	time.sleep(float(seconds))

def print_hex(file_name):
	with open(file_name, 'rb') as file: bytes=file.read()
	for i in range(len(bytes)):
		print('{:02x}'.format(ord(bytes[i])), end=' ')
		if i%4==3: print(end=' ')
		if i%16==15: print()
	print()

#=====git=====#
def gcaapf():
	_invoke('git caa')
	_invoke('git pf')

def gsmu():
	_invoke('git submodule update --remote')
	_invoke('git submodule foreach "git submodule update --init --recursive"')

#=====help=====#
def help(command=None):
	import inspect
	if command==None:
		print('list of commands:')
		print(sorted([i for i in globals() if callable(eval(i)) and not i.startswith('_')]))
	else:
		print(inspect.getdoc(eval(command)))
		print(inspect.getargspec(eval(command)))

#=====main=====#
parser=argparse.ArgumentParser()
parser.add_argument('--dry', action='store_true', help='only print invocations')
parser.add_argument('-l', action='store_true', help='run on each stdin line')
parser.add_argument('command')
parser.add_argument('args', nargs='*')
if len(sys.argv)==1: help()
args=parser.parse_args()

try: eval(args.command)
except: help(); raise
try:
	if args.l:
		for line in sys.stdin.readlines():
			exec(args.command+'(*[i.format(line.strip()) for i in args.args])')
	else: exec(args.command+'(*args.args)')
except TypeError: help(args.command); raise
