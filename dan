#!/usr/bin/env python3

from __future__ import print_function

import argparse
import datetime
import functools
import inspect
import os
import platform
import pprint
import re
import secrets
import shutil
import string
import subprocess
import sys
import tempfile
import time
import webbrowser

class _Emoji:
    explode = '\U0001f4a5'
    neutral = '\U0001f610'

try: _input = raw_input
except: _input = input

this = os.path.realpath(__file__)

try:
    computer = subprocess.check_output('hostname').decode().strip()
except:
    computer = None

class _Section:
    def __init__(self):
        self.line = inspect.stack()[1][2]

class _SubSection(_Section): pass

def _home_path(path=''): return os.path.join(os.path.expanduser('~'), *path.split('/'))
def _this_path(path=''): return os.path.join(os.path.split(this)[0], *path.split('/'))
def _scripts_path(path=''): return _home_path('Desktop/scripts/'+path)
def _tmp_path(path=''):
    tmp = _this_path('tmp')
    os.makedirs(tmp, exist_ok=True)
    return os.path.join(tmp, path)

def _invoke(invocation, stdin=None, stdout=None):
    if args.dry:
        print(invocation)
        return
    if stdout is not None:
        return subprocess.check_output(invocation, shell=True, stdin=stdin).decode().strip()
    else:
        subprocess.check_call(invocation, shell=True, stdin=stdin)

def _platform_invoke(linux=None, darwin=None, windows=None, **kwargs):
    invocation = {
        'Linux': linux,
        'Darwin': darwin,
        'Windows': windows,
    }[platform.system()]
    if invocation == None: raise Exception('unimplemented')
    return _invoke(invocation, **kwargs)

def _check():
    if args.force: return
    import traceback
    traceback.print_stack()
    print('confirm action (y/n)')
    if input().lower() != 'y':
        print('aborting')
        sys.exit(0)
    else:
        print('confirmed')

def _clipboard_paste(**kwargs):
    return _platform_invoke(
        linux='xclip -selection clipboard -o',
        darwin='pbpaste',
        **kwargs
    )

opener = None
if platform.system() == 'Windows':
    opener = 'explorer'
else:
    if   not subprocess.call('which xdg-open>/dev/null', shell=True): opener = 'xdg-open'
    elif not subprocess.call('which open    >/dev/null', shell=True): opener = 'open'

_dan_bash = '''
#===== config =====#
force_color_prompt=yes
PATH=$PATH:~/Desktop/scripts
PS1='\\e[0;37;44m               $?               \\e[m \n\\h \\D{{%Y-%m-%d}} \\t \\w$ '

#===== aliases =====#
#----- folders -----#
alias pg="cd ~/Desktop/repos/playground"
alias repos="cd ~/Desktop/repos"

#----- sleep -----#
alias ds="dan dan \\"wait 3600\\" \\"sleep\\""
alias dsd="dan sleep deep"
alias dss="dan sleep"

#----- brightness -----#
alias b="dan b 40"
alias bb="dan b 500"
alias bn="dan b 4"
alias bnn="dan b -4"

#----- sourcing -----#
function dg {{
    if [ -n "$1" ]; then
        cd `dan bookmark_get $1`
    else
        dan bookmark_get
    fi
}}

function dpv {{
    env | grep VIRTUAL_ENV > /dev/null
    if [ $? -eq 0 ]; then
        deactivate;
    else
        source venv/bin/activate;
    fi
}}

#----- shortcuts -----#
alias o="{opener} ."
alias p3=python3
alias dkr="sudo docker"
alias tp="dan rename_tab_pwd; export DAN_TAB_NAME_KEEP=1"
alias d="python3 do.py"

function tn {{
    dan rename_tab "$1"
    export DAN_TAB_NAME_KEEP=1
}}

function tt {{
    dan rename_tab "|| $1 ||"
    export DAN_TAB_NAME_KEEP=1
}}

#----- overrides -----#
alias vi="dan rename_tab_and_open vi"

#----- docker -----#
alias dkril="sudo docker image ls"
alias dkrcl="sudo docker container ls --all"
function dkrb {{
    sudo docker build -t $1 .
}}
function dkrr {{
    sudo docker run --name $1 --detach ${{@:2}} $1:latest
}}
function dkrsh {{
    sudo docker exec -it $1 /bin/sh
}}

#===== external scripts =====#
if [ -f ~/git-completion.bash ]; then source ~/git-completion.bash; fi

#===== breadcrumb =====#
echo "dan bash ran"
'''.format(opener=opener)

if os.path.exists(_scripts_path('dan-aliases.txt')):
    with open(_scripts_path('dan-aliases.txt')) as file:
        _dan_bash += file.read()

#=====commands=====#
_computer = _Section()

def sleep(type=None):
    'put computer to sleep'
    if type == 'deep':
        for i in [
            'LID0',
            'SLPB',
            'UHC0',
            'UHC1',
            'UHC2',
            'UHC3',
            'UHC4',
            'UHCR',
            'EHC1',
            'EHC2',
        ]:
            _invoke('sudo sh -c "echo {} > /proc/acpi/wakeup"'.format(i))
    _invoke('systemctl suspend')

def reboot():
    'reboot computer'
    _check()
    _invoke('reboot')

def off():
    'turn computer off'
    _check()
    _platform_invoke('sudo poweroff', 'sudo halt')

def vu():
    'volume up'
    _invoke('pactl -- set-sink-volume 0 +10%')

def vd():
    'volume down'
    _invoke('pactl -- set-sink-volume 0 -10%')

def _brightness(level):
    #find path on new computer with `sudo find /sys/ -type f -iname '*brightness*'`
    if computer == 'dan-ThinkPad-13':
        path = '/sys/devices/pci0000:00/0000:00:02.0/drm/card0/card0-eDP-1/intel_backlight/brightness'
        level /= 1000
    else:
        path = '/sys/class/backlight/intel_backlight/brightness'
    if level == 'get':
        with open(path) as file:
            return int(file.read())
    _invoke('echo {}|sudo tee {}'.format(int(level), path))

def b(level):
    'set brightness'
    if level == 'get': return (_brightness('get')-5000)/1000.0
    _brightness(int(float(level)*1000+5000))

def bu():
    'brightness up'
    b(b('get')*2)

def bd():
    'brightness down'
    b(b('get')//2)

def install(command):
    'append a note of this command to Desktop/dan-install.txt'
    with open(_home_path('Desktop/dan-install.txt'), 'a') as file:
        file.write(timestamp(False)+'\n')
        file.write(command+'\n')
        file.write('\n')
    _invoke(command)

def kill(name):
    'kill a process by name'
    lines = [
        i
        for i in _invoke('ps -e', stdout=True).splitlines()
        if name in i
    ]
    if len(lines) > 1:
        print('multiple matches')
        for line in lines: print(line)
    elif not lines:
        print('no matches')
    else:
        line = lines[0]
        print(line)
        proc = line.split()[0]
        print('killing', proc)
        _invoke(f'kill -9 {proc}')

def kill_the_greedy():
    while True:
        if int(subprocess.check_output(['free']).decode().split()[12]) < 100000:
            info = subprocess.check_output(['ps', '-e', '--sort', '%mem']).decode().split()[-4:] 
            subprocess.check_call(['kill', info[0]])
            print('killed {}'.format(info[-1]))
        time.sleep(0.1)

_convenience = _Section()
_convenience_text = _SubSection()

def _put_in_clipboard(contents):
    stdin = tempfile.TemporaryFile(mode='w')
    stdin.write(contents)
    stdin.seek(0)
    _platform_invoke(
        linux='xclip -selection clipboard',
        darwin='pbcopy',
        stdin=stdin,
    )

def c(*args):
    'copy stdin to clipboard'
    _put_in_clipboard(stdin)

def v():
    'paste clipboard to stdout'
    _clipboard_paste()

_snippet_prefix = 'dan-snippet-'

def snipw(name):
    'take clipboard contents and save it as a snippet'
    with open(_scripts_path(_snippet_prefix+name), 'wb') as file:
        file.write(subprocess.check_output('dan v', shell=True))

def snipr(name):
    'put snippet contents into clipboard'
    with open(_scripts_path(_snippet_prefix+name)) as file:
        _put_in_clipboard(file.read())

def snipl():
    'list snippets'
    snippets = []
    for i in sorted(os.listdir(_scripts_path())):
        if i.startswith(_snippet_prefix):
            with open(_scripts_path(i)) as file:
                first_line = file.readlines()[0].strip()
            snippets.append((i[len(_snippet_prefix):], first_line))
    space = max([len(i[0]) for i in snippets])
    for name, first_line in snippets:
        print(('{:'+str(space)+'}: {}').format(name, first_line))

def replace(pattern, replacement, file_pattern='.*'):
    for root, dirs, files in os.walk('.'):
        for i in files:
            path = os.path.relpath(os.path.join(root, i))
            if re.match(file_pattern, path):
                with open(path) as file: contents = file.read()
                contents, replacements = re.subn(pattern, replacement, contents)
                if not replacements: continue
                with open(path, 'w') as file: file.write(contents)
                print(f'made {replacements} replacement(s) in {path}')

_convenience_time = _SubSection()

def timestamp(ambiguous=True, when=None):
    if when == None: when = datetime.datetime.now()
    format = '{:%Y-%m'
    if not ambiguous: format += '-%b'
    format += '-%d %H:%M:%S.%f}'
    return format.format(when).lower()

def wait(seconds):
    'wait for specified number of seconds'
    import time
    time.sleep(float(seconds))

_convenience_encoding = _SubSection()

def print_hex(file_name):
    'print specified file in hex'
    with open(file_name, 'rb') as file: bytes = file.read()
    for i in range(len(bytes)):
        print('{:02x}'.format(ord(bytes[i])), end=' ')
        if i%4 == 3: print(end=' ')
        if i%16 == 15: print()
    print()

def json():
    'take json from clipboard and pretty print'
    j = _clipboard_paste(stdout=True)
    import json
    pprint.pprint(json.loads(j))

def base64():
    'take base64 from clipboard and print'
    x = _clipboard_paste(stdout=True)
    import base64
    print(base64.b64decode(x))

_convenience_navigation = _SubSection()

def find(regex, n=None, flags='i'):
    '''\
find files and directories matching regex within current directory
if n is specified, print only the nth file that matches'''
    if n != None: n = int(n)
    flags = functools.reduce(lambda a, b: a|b, [getattr(re, flag.upper()) for flag in flags])
    count = 0
    for root, dirs, files in os.walk('.'):
        for base in dirs+files:
            path = os.path.join(root, base)
            if re.search(regex, path, flags):
                count += 1
                if n == None or count == n:
                    print(path)
                    if count == n: break
        else: continue
        break

def walk(command):
    'walk current path, invoking command on each file'
    paths = []
    for dirpath, dirnames, filenames in os.walk('.'):
        for filename in filenames:
            paths.append(os.path.join(dirpath, filename))
    for path in sorted(paths):
        _invoke('{} "{}"'.format(command, path))

def regex(pattern, file_name):
    r'''find regex in file
use \\ to split pattern across lines'''
    pattern = pattern.split(r'\\')
    with open(file_name) as file: lines = file.readlines()
    for i in range(len(lines)):
        for j in range(len(pattern)):
            if not re.search(pattern[j], lines[i+j]): break
        else:
            if len(pattern) == 1:
                print('{}@{}: {}'.format(file_name, i+1, lines[i].rstrip()))
            else:
                print('{}@{}:'.format(file_name, i+1))
                for j in range(len(pattern)): print(lines[i+j].rstrip())
                print('')

def last(index=1):
    'print last item in stdin'
    print(sorted([i.strip() for i in stdin.split()])[-int(index)])

def bookmark_set(name):
    'bookmark current directory under specified name'
    with open(_scripts_path('dan-bookmarks.txt'), 'a') as file:
        file.write('{} {}\n'.format(name, os.getcwd()))

def bookmark_get(name=None):
    '''\
print bookmark corresponding to specified name
leave args empty to see list of bookmarks'''
    possibilities = {}
    all = {}
    with open(_scripts_path('dan-bookmarks.txt')) as file:
        for line in file.readlines():
            i, j = line.split()
            if name and i.startswith(name): possibilities[i] = j
            all[i] = j
    if len(possibilities) == 0: pprint.pprint(all); return
    print(min(possibilities.items(), key=lambda i: len(i[0]))[1])

def rename_tab(name):
    print('\x1b]2;{}\a'.format(name))

def rename_tab_and_open(program, path=''):
    if not int(os.environ.get('DAN_TAB_NAME_KEEP', 0)):
        tab_name = path
        if len(tab_name) > 12: tab_name = os.path.basename(tab_name)
        rename_tab(tab_name)
    _invoke('{} {}'.format(program, path))

def rename_tab_pwd():
    rename_tab(os.path.basename(os.path.abspath(os.getcwd())))

def link(link, linked):
    'create symlink'
    _invoke('ln -s {} {}'.format(linked, link))

def alias(name, command):
    'create a semipermanent alias'
    with open(_scripts_path('dan-aliases.txt'), 'a') as file:
        file.write('alias {}={}\n'.format(name, command))

_convenience_useful_forgettable_tools = _SubSection()

def disk_usage():
    try:
        _invoke('ncdu')
        return
    except Exception as e: print(e)
    print('ncdu failed, resorting to df')
    _invoke('df -h')

def monitor(): _invoke('top')

def network_discover(): _invoke('avahi-discover')

def user_bin_path(): _invoke('systemd-path user-binaries')

_convenience_ssh = _SubSection()

def ssh_save(name):
    shutil.copytree(_home_path('.ssh'), _home_path('.ssh-'+name))

def ssh_list():
    import glob
    print([i.split('ssh-')[-1] for i in glob.glob(_home_path('.ssh-*'))])

def ssh_load(name):
    shutil.rmtree(_home_path('.ssh'), True)
    name = _home_path('.ssh-'+name)
    shutil.copytree(name, _home_path('.ssh'))

_convenience_git = _SubSection()

def gcaapf():
    'git add and amend commit, then force push'
    _invoke('git commit -a --amend --no-edit')
    _invoke('git pf')

def gsmu():
    'git update submodules to latest, and sync their submodules'
    _invoke('git submodule update --remote')
    _invoke('git submodule foreach "git submodule update --init --recursive"')

def grbo():
    'git remote branch owners (most recent committers)'
    b = _invoke('git ls-remote -qh', stdout=True).splitlines()
    b = [i.split()[1][len('refs/heads/'):] for i in b]
    results = []
    for i in b:
        rev = 'origin/'+i
        split = 'vlkaeiwhvi4uhlksajhdvkausdhv'
        author, date = _invoke('git show -q --pretty="format:%an{}%ai" {}'.format(split, rev), stdout=True).split(split)
        results.append((rev, author, date))
    results = sorted(results, key=lambda x: x[2])
    a = str(max([len(i[0]) for i in results]))
    b = str(max([len(i[1]) for i in results]))
    for i in results:
        print(('{:'+a+'} {:'+b+'} {}').format(*i))

def gfor(commit, invocation):
    'run specified invocation on each commit from HEAD to specified commit'
    log = _invoke('git log --graph --pretty="%h %an" {}..HEAD'.format(commit), stdout=True).splitlines()
    for line in log:
        print(line)
        m = re.match('[| *]* ([^ ]+)', line)
        if not m: continue
        commit = m.group(1)
        _invoke('git checkout {}'.format(commit))
        _invoke(invocation)

def grecent():
    'show recent commits in repos in current directory'
    for i in os.listdir('.'):
        os.chdir(i)
        if os.path.exists('.git'):
            log = _invoke('git log --graph --pretty="%h a:%ai c:%ci %s" --since="1 day ago"', stdout=True)
            if log:
                print(i)
                print(log)
        os.chdir('..')

_convenience_inlining = _SubSection()

def invoke(invocation, *args):
    'invocation with python-style substitutions'
    _invoke(invocation.format(*args))

def p(expression, should_print='1'):
    'python exec expression'
    if eval(should_print): expression = 'print({})'.format(expression)
    exec(expression)

def py(format=None, *args):
    'run python code from stdin; useful in vim `:w !dan py`'
    with open(_tmp_path('tmp.py'), 'w') as f:
        f.write(stdin)
    _invoke('python3 {}'.format(_tmp_path('tmp.py')))

def php():
    'run php code from stdin; useful in vim `:w !dan php`'
    with open(_tmp_path('tmp.php'), 'w') as f:
        f.write('<?php\n')
        f.write(stdin)
    _invoke('php -f {}'.format(_tmp_path('tmp.php')))

def cpp():
    'run c++ code from stdin; useful in vim `:w !dan cpp`'
    obvious_path = os.path.expanduser('~/Desktop/repos/obvious/cpp/obvious.hpp')
    with open(_tmp_path('tmp.cpp'), 'w') as f:
        f.write('#include <cmath>\n')
        f.write('#include <cstdlib>\n')
        f.write('#include <ctime>\n')
        f.write('#include <fstream>\n')
        f.write('#include <iostream>\n')
        f.write('#include <map>\n')
        f.write('#include <set>\n')
        f.write('#include <sstream>\n')
        f.write('#include <thread>\n')
        f.write('#include <vector>\n')
        if os.path.exists(obvious_path):
            f.write('#include "{}"\n'.format(obvious_path))
        f.write('using namespace std;\n')
        if 'main' not in stdin: f.write('int main(){')
        f.write(stdin)
        if 'main' not in stdin: f.write('}')
    _invoke('g++ -o {} {}'.format(_tmp_path('tmp'), _scripts_path('tmp.cpp')))
    _invoke(_tmp_path('tmp'))

def rust():
    'run rust code from stdin; useful in vim `:w !dan rust`'
    global stdin
    if 'fn main(' not in stdin:
        stdin = 'fn main() {' + stdin + '}'
    with open(_tmp_path('tmp.rs'), 'w') as f:
        f.write(stdin)
    _invoke('rustc -o {} {}'.format(_tmp_path('tmp'), _tmp_path('tmp.rs')))
    _invoke(_tmp_path('tmp'))

def cargo():
    'like `rust` but allows crate dependencies to be specified as well'
    os.chdir(_tmp_path())
    if not os.path.exists('cargo'):
        _invoke('cargo new cargo')
    os.chdir('cargo')
    with open('Cargo.toml') as f:
        cargo = f.read()
    deps = []
    for line in stdin.splitlines():
        if line.startswith('///cargo-deps'):
            deps.extend(line.split()[1:])
    cargo = re.sub(
        r'\[dependencies\].*',
        '\n'.join(
            ['[dependencies]']
            +
            [i + ' = "*"' for i in deps]
        ),
        cargo,
        flags=re.DOTALL,
    )
    with open('Cargo.toml', 'w') as f:
        f.write(cargo)
    with open(os.path.join('src', 'main.rs'), 'w') as f:
        f.write(stdin)
    _invoke('cargo run')

_convenience_misc = _SubSection()

def browser(url):
    webbrowser.open(url)

def dan(*args):
    'invoke this script on each arg in order'
    ' -- useful for creating compound statements, for example in an alias'
    for arg in args: _invoke('dan '+arg)

def pyre(pattern, repl):
    'python regex'
    print(re.sub(pattern, repl, stdin), end='')

def hista():
    '''\
Print out a command that will immediately update history on mac.
So you'd use it like `dan hista`.
history doesn't work right, seemingly because it's a builtin.'''
    print('history -w {}'.format(_home_path('.bash_history')))

def password(special_chars='!@#$%&*'):
    print(''.join(
        secrets.choice(string.ascii_letters + string.digits + special_chars)
        for i in range(32)
    ))

def eol():
    for root, dirs, file_names in os.walk(os.getcwd()):
        for file_name in file_names:
            path = os.path.join(root, file_name)
            print(path)
            with open(path) as file:
                try:
                    if '\r\n' in file.read():
                        print(_Emoji.neutral+'DOS line endings detected!')
                except:
                    print(_Emoji.explode+'Exception while checking')

def lint():
    'Lint whatever is in the current directory.'
    if os.path.exists('Cargo.toml'):
        _invoke('cargo fmt')
        _invoke('cargo clippy')

_crypto = _Section()

def crypto_import(file_name):
    subprocess.run(['gpg', '--import', file_name])

def crypto_list_public_keys():
    subprocess.run(['gpg', '-k'])

def crypto_encrypt(file_name):
    subprocess.run(['gpg', '-e', file_name])

def crypto_decrypt(file_name):
    subprocess.run(['gpg', file_name])

_setup = _Section()

def install_self():
    'hook into bash init script'
    if platform.system() != 'Windows':
        #find bash init script
        bash_init = None
        if os.path.exists(_home_path('.bash_profile')): bash_init = _home_path('.bash_profile')
        elif os.path.exists(_home_path('.bashrc')): bash_init = _home_path('.bashrc')
        if not bash_init:
            print("couldn't find a bash init script!")
            sys.exit(1)
        #append if not already done
        header = "#===== appended by dan from dansgithubuser's playground =====#"
        already_done = False
        with open(bash_init, 'r') as file:
            for line in file.readlines():
                if header in line:
                    already_done = True
                    break
        if not already_done:
            print('I will append to {} and make it use my bash command -- if that is OK, enter y'.format(bash_init))
            if _input() != 'y': sys.exit(1)
            with open(bash_init, 'a') as file:
                file.write('\n'.join([
                    '',
                    '',
                    header,
                    f'python3 {this} bash',
                    f'source {_home_path("Desktop/scripts/dan-bash.sh")}',
                    '',
                    '# pyenv',
                    'export PYENV_VERSION=3.7.4',
                    'export PYENV_ROOT="$HOME/.pyenv"',
                    'export PATH="$PYENV_ROOT/bin:$PATH"',
                    '#eval "$(pyenv init -)"',
                    '',
                    '# rust',
                    '#source ~/.cargo/env',
                    '#===== end dan =====#',
                ]))
    else:
        for root, dirs, files in os.walk(_this_path('windows-portable')):
            for file in files:
                path = os.path.join(root, file)
                shutil.copy(path, path[:-len('.disguise')])
        with open(_scripts_path('init.bat'), 'w') as file: file.write(rf'@PATH=%PATH%;{_scripts_path()};{_this_path("windows-portable")}')
        with open(_scripts_path('dan.bat'), 'w') as file: file.write(f'python {this} %*')
        _invoke('reg add "HKCU\Software\Microsoft\Command Processor"'
            ' /v AutoRun ^'
            ' /t REG_EXPAND_SZ'
            f''' /d "{_scripts_path('init.bat')}"'''
            ' /f'
        )
    #other stuff
    vi()
    git()

def bash():
    'update bash setup, writes to ~/Desktop/scripts/'
    try: os.makedirs(_scripts_path(''))
    except: pass
    shutil.copy(this, _scripts_path(''))
    with open(_scripts_path('dan-bash.sh'), 'w') as file: file.write(_dan_bash)
    if platform.system() == 'Linux':
        disable_capslock()

_vimrc = '''\
set autoindent
set number
set list
set listchars=tab:>-
set nocompatible
syntax on
set pastetoggle=<F2>
set ignorecase
set smartcase
set backspace=indent,eol,start
set noswapfile
set relativenumber
nnoremap / /\\v
vnoremap / /\\v
set gdefault
set smartcase

" color scheme
colorscheme darkblue
hi Whitespace ctermfg=DarkBlue
match Whitespace /\s/

" helpers
function SpacesForIndent(n)
    setlocal expandtab
    let &tabstop=a:n
    let &softtabstop=a:n
    let &shiftwidth=a:n
endfunction

" infer particular settings from contents of file
function SettingsForContent()
    " Determines whether to use spaces or tabs on the current buffer.
    if getfsize(bufname("%")) > 256000
        " File is very large, just use the default.
        " Turn off syntax highlighting too!
        setlocal syntax=off
        return
    endif

    let numTabs=len(filter(getbufline(bufname("%"), 1, 250), 'v:val =~ "^\\t"'))
    let num2Spaces=len(filter(getbufline(bufname("%"), 1, 250), 'v:val =~ "^  [^ ]"'))
    let num4Spaces=len(filter(getbufline(bufname("%"), 1, 250), 'v:val =~ "^    [^ ]"'))

    if max([num2Spaces, num4Spaces]) > numTabs
        if num2Spaces > 0
            call SpacesForIndent(2)
        else
            call SpacesForIndent(4)
        endif
    elseif numTabs > 0
        setlocal noexpandtab
    endif
endfunction
autocmd BufReadPost * call SettingsForContent()

" semantic highlighting
autocmd BufEnter * :syntax sync fromstart
autocmd BufEnter * :let g:semanticUseBackground = 1
" press comma s to toggle semantic highlighting
nnoremap ,s :SemanticHighlightToggle<cr>

" settings for file types
let ext=expand('%:e')
if index(["py", "md", "rs"], ext)!=-1
    call SpacesForIndent(4)
elseif index(["html", "css", "js"], ext)!=-1
    call SpacesForIndent(2)
elseif index(["c", "h", "cpp", "hpp"], ext)!=-1
    setlocal tabstop=2
    setlocal shiftwidth=2
endif
'''

def vi():
    'setup vi stuff'
    p = _home_path('.vimrc')
    print('I will create a vimrc file, it requires package vim-gui-common.')
    if os.path.exists(p): print('I will overwrite the existing one.')
    print('If that is OK, enter y.')
    if _input() != 'y': sys.exit(1)
    with open(p, 'w') as file: file.write(_vimrc)
    if platform.system() == 'Windows':
        with open(_scripts_path('vi.bat'), 'w') as file:
                file.write(r'"C:\Program Files\Git\usr\bin\vim" %*')

def git():
    'update git aliases, download git-completion.bash, set conflict style to diff3'
    with open(_this_path('git-aliases.txt')) as file:
        for line in file.readlines():
            if platform.system() == 'Windows':
                if 'alias.sf' in line: continue
            _invoke(line)
    if platform.system() != 'Windows':
        _invoke('curl https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash > ~/git-completion.bash')
    _invoke('git config --global merge.conflictstyle diff3')

def disable_capslock():
    _invoke('xmodmap -e "keycode 66 = Shift_L NoSymbol Shift_L"')

_esoteric = _Section()

def _getmtime(path):
    return timestamp(False, datetime.datetime.fromtimestamp(os.path.getmtime(path)))

def getmtime(path):
    'get modified time of specified path'
    print('{} {}'.format(_getmtime(path), path))

def _exif(path, key):
    import exifread
    with open(path, 'rb') as file: tags = exifread.process_file(file)
    if key == '*': return tags
    return tags.get(key, None)

def exif(path, key='*'):
    'get exif data from path'
    if key == '*':
        import pprint
        pprint.pprint(_exif(path, '*'))
    print('{} {}'.format(_exif(path, key), path))

def google_photos_time(path):
    'get creation time of image downloaded from google photos (?)'
    x = _exif(path, 'Image DateTime')
    if x:
        x = timestamp(False, datetime.datetime(*[int(i) for i in re.split(':| ', x.values)]))
    else: x = _getmtime(path) or '?'
    print('{}\t{}'.format(x, path))

def lines_run_length(pattern='.*'):
    previous = None
    body = []
    def p():
        if not body: return
        print('{:6} {}'.format(len(body), previous))
        for i in body: print('\t'+i)
    def e(l):
        return re.match(pattern, l).group(0)
    for line in lines:
        line = line.strip()
        if e(line) != previous:
            p()
            body = []
        previous = e(line)
        body.append(line)
    p()

_conservative_logrotate_conf = '''size 1M
rotate 0
create
include /etc/logrotate.d
/var/log/wtmp {
    missingok
    monthly
    create 0664 root utmp
    rotate 1
}

/var/log/btmp {
    missingok
    monthly
    create 0660 root utmp
    rotate 1
}
'''

_conservative_rsyslog = '''/var/log/syslog
{
    rotate 0
    size 1M
    missingok
    postrotate
        invoke-rc.d rsyslog rotate > /dev/null
    endscript
}

/var/log/mail.info
/var/log/mail.warn
/var/log/mail.err
/var/log/mail.log
/var/log/daemon.log
/var/log/kern.log
/var/log/auth.log
/var/log/user.log
/var/log/lpr.log
/var/log/cron.log
/var/log/debug
/var/log/messages
{
    rotate 0
    size 1M
    missingok
    sharedscripts
    postrotate
        invoke-rc.d rsyslog rotate > /dev/null
    endscript
}
'''

def conservative_logrotate():
    _check()
    with open('/etc/logrotate.conf') as file: file.write(_conservative_logrotate_conf)
    with open('/etc/logrotate.d/rsyslog') as file: file.write(_conservative_rsyslog)

def rm_crash_dumps():
    'remove files that cause ubuntu to ask you if you want to report a detected problem'
    _invoke('sudo rm /var/crash/*')

def static_ip():
    '''\
Useful for connecting to wrt54gl running openwrt 
in failsafe mode (hold reset, power on, wait ~10s until dmz lights up, let go, see power and dmz lights flash, connect with `telnet 192.168.1.1`) 
or if its DHCP is disabled and its IP is x.x.1.x. 
If the IP is something else, make sure the 3rd numbers match in the command below.'''
    _check()
    _invoke('sudo ifconfig enp1s0 192.168.1.3 netmask 255.255.255.0')

def naive_bracket_format(indent_size=2):
    'take input from clipboard and print with indentation based on parens, brackets, and braces'
    x = _clipboard_paste(stdout=True)
    indent = 0
    print_spaces = True
    for i in x:
        if i in '([{':
            print(i)
            indent += indent_size
            print(' ' * indent, end='')
            print_spaces = False
        elif i in ')]}':
            print('')
            indent -= indent_size
            print(' ' * indent, end='')
            print(i, end='')
        elif i == ' ':
            if print_spaces:
                print(i, end='')
        else:
            print(i, end='')
            print_spaces = True

_help = _Section()

def _get_commands():
    return sorted(
        [i for i in globals() if callable(eval(i)) and not i.startswith('_')],
        key=lambda x: inspect.getsourcelines(eval(x))[1],
    )

def h(command=None):
    'help'
    if command == None:
        sections = sorted(
            [i for i in globals() if isinstance(eval(i), _Section)],
            key=lambda x: eval(x).line
        )
        section = 0
        commands = _get_commands()
        max_len_command = max([len(i) for i in commands])
        for command in commands:
            while section < len(sections) and inspect.getsourcelines(eval(command))[1] > eval(sections[section]).line:
                title = sections[section][1:]
                if isinstance(eval(sections[section]), _SubSection):
                    line_char = '-'
                    title = ' '.join(title.split('_')[1:])
                else:
                    line_char = '='
                line = line_char * max_len_command
                print(f'\n{line} {title} {line}')
                section += 1
            full_help = inspect.getdoc(eval(command))
            if full_help:
                full_help = full_help.splitlines()
                short_help = full_help[0]
                if len(full_help) > 1: short_help += '...'
            else: short_help = ''
            print(('{:>'+str(max_len_command)+'}  {}').format(command, short_help))
    else:
        print(inspect.getdoc(eval(command)))
        print(inspect.getfullargspec(eval(command)))

#=====main=====#
parser = argparse.ArgumentParser(description='`dan h` to list commands, `dan h command` for help with specific command')
parser.add_argument('--dry', action='store_true', help='only print invocations')
parser.add_argument('-l', action='store_true',
    help='take a Python iterable from stdin and run command on each item')
parser.add_argument('--quiet', '-q', action='store_true')
parser.add_argument('--force', '-f', action='store_true', help='bypass checks for system-altering commands')
parser.add_argument('command')
parser.add_argument('args', nargs='*', help='use {} to sub stdin')
if len(sys.argv) == 1: h()
args = parser.parse_args()

if not args.quiet:
    sys.stderr.write('invoked with: {}\n'.format(sys.argv))

def _translate_lazy(lazy, possibilities):
    if lazy in possibilities:
        return possibilities[lazy]
    candidates = []
    for i in possibilities:
        if re.search('.*'.join(lazy), i):
            candidates.append(i)
    def reduce(ls, f):
        x = [i for i in candidates if f(i)]
        return x if x else ls
    candidates = reduce(candidates, lambda i: i.startswith(lazy[0]))
    candidates = reduce(candidates, lambda i: i.endswith(lazy[-1]))
    if len(candidates) == 1:
        result = possibilities[candidates[0]]
        if lazy != result.__name__:
            print(f'{lazy} interpreted as {result.__name__}')
        return result
    h()
    raise AttributeError("couldn't resolve {}, candidates:\n{}".format(
        lazy, '\n'.join(candidates),
    ))

try:
    #if you read from stdin with no input, run blocks for input
    #this is the best way I could find to check for input
    if not sys.stdin.isatty():
        stdin = sys.stdin.read()
    else:
        stdin = ''
    def _ex(args, stdin):
        commands = _get_commands()
        f = _translate_lazy(args.command, {i: eval(i) for i in commands})
        if stdin:
            result = f(*[i.format(stdin) for i in args.args])
        else:
            result = f(*args.args)
        if result: print(result)
    if args.l:
        outer_stdin = stdin
        del stdin
        for stdin in eval(outer_stdin):
            _ex(args, stdin)
    else: _ex(args, stdin)
except TypeError: h(args.command); raise
